---
layout: post
title: Hello, World!  
---

<p> &emsp;&emsp;&emsp;&emsp;&emsp; Inspired by <a href="https://xkcd.com/1071/"> XKCD's Exoplanet comic</a>, here is a visualization of all the exoplanets and their stars to scale. The pink blob is our sun, and in it is a tiny speck that is our planet. You can spot earth if you zoom in and look very closely for a tiny black dot.</p>
<div id="project-2"></div>
<script src="http://d3js.org/d3.v3.min.js"></script>

<style>
  #project-2{
    position: relative;
    left: -60px;
    top: -40px;
  }
</style>

<script type = "text/javascript">

    var size = 800;
    var m = 1;

    var padding = 0.50;
    var clusterPadding = 4;
    var starCluster = [];
    var maxRadius = 1;

    // get distance from star, see if you can sort if according to that
    // fix the colors of the planets

    var svg = d3.select("div#project-2").append("svg").attr("width",size).attr("height",size);

    var colorstar = d3.scale.quantize().range(['rgb(77,0,75)','rgb(129,15,124)','rgb(136,65,157)','rgb(140,107,177)','rgb(140,150,198)']);

    var starpack = d3.layout.pack()
          .sort(null)  // sort data later according to distance
          .size([size,size])
          .value(function(d) {return d.radius })
          .padding(clusterPadding);


    /*----Star----*/
    d3.csv("extrastars.csv", type, function(error, dat){

      // create empty array
      var planet = [];

      for(var i = 0; i< dat.length; i++){
         var thisP = dat[i];
         var c = thisP.cluster;
         var r = thisP.pradius / m * -Math.log(0.85) * maxRadius;
         planet.push({planet: thisP.planet, radius: r , cluster: thisP.cluster, star: thisP.star, realr: thisP.pradius, distance: thisP.distance});
      }

      /*
      dat.forEach(function(entry,i){
        var thisP = dat[i]; // get data at i
        var c = thisP.cluster;
        var r = thisP.pradius / m * -Math.log(0.85) * maxRadius;
        planet.push({planet: thisP.planet, radius: r , cluster: thisP.cluster, star: thisP.star, realr: thisP.pradius, distance: thisP.distance});
      }); */

      var tempStar = {};

      for(var i = 0; i < dat.length; i++){
          var thisS = dat[i];
          if(!tempStar[thisS.star]){
            // store an object
            tempStar[thisS.star] = {star: thisS.star, radius: thisS.sradius, luminosity: thisS.luminosity, distance: thisS.distance, cluster: thisS.cluster};
          }
      }

      /*
      dat.forEach(function(entry,i){
        // get data at i
        var thisS = dat[i];
        // if this associate array has not yet been defined
        if(!tempStar[thisS.star]){
          // store an object
          tempStar[thisS.star] = {star: thisS.star, radius: thisS.sradius, luminosity: thisS.luminosity, distance: thisS.distance, cluster: thisS.cluster};
        }
      }); */


      // define array
      var star = [];
      for(var key in tempStar){
        star.push(tempStar[key]);
      }


      star.sort(function(a,b){
        return isFinite(a.distance) || isFinite(b.distance)
        ? a.distance - b.distance
        : 0;
      });

      var snode = starpack.nodes({children: star}).slice(1);

      colorstar.domain(d3.extent(star, function(d){return d.luminosity;}));

      var starNode = svg.selectAll(".star")
        .data(snode) // so confusing
        .enter().append("circle")
        .attr("r", function(d) {
          starCluster[d.cluster] = d;   // will this work?
          return d.r - 0.5;
        })
        .attr("cx", function(d){return d.x;})
        .attr("cy", function(d){return d.y;})
        .attr("fill", function(d){
          if(d.star == "Sun"){return '#F08080';}
          //return colorstar(d.luminosity);
          //return "rgb(248,114,23)"
          return "#B0C4DE";
        })
        .style("opacity", 1)
        .attr("stroke", "grey")
        .attr("stroke-width", "1.45")
        .attr("class", "star");


      var force = d3.layout.force()
              .nodes(planet)
              .size([size, size])
              .gravity(0)
              .charge(0)
              .on("tick", tick)
              .start();


        var planetNode = svg.selectAll(".planet")
            .data(planet)
            .enter().append("circle")
            .call(force.drag)  
            .attr("fill", function(d){
              if(d.planet == "Earth"){
                return "black";
              } /*
              else if(d.star == "Sun") {
                return "orange";
              } */
              return "#ffffff";//"#FFFF00"; //"#ffffff"; //"rgb(248,114,23)";//"rgb(235,225,120)"; //rgb(83,216,235) //
            })
            .attr("class", "planet");


        planetNode.sort(function(a,b){
        return isFinite(a.distance) || isFinite(b.distance)
          ? a.distance - b.distance
          : 0;
        });



        planetNode.transition()
          .duration(1000)
          .delay(function(d,i) {return i * 17;})
          .attrTween("r", function(d){
              var i = d3.interpolate(0, d.radius);
              return function(t) {return d.radius = i(t);};     
          });


       d3.selectAll(".planet")
            .on("click", function(d){
               console.log(d);
            });



      function tick(e){
        // call tick on the planets
        planetNode
          .each(cluster(10 * e.alpha * e.alpha))
          .each(collide(0.2))
           // if you don't have this they become one cluster
           // collision is not happening correctly
          .attr("cx", function(d) {
            return d.x;
          })
            .attr("cy", function(d) {
              return d.y;
            });
      }



      function cluster(alpha){

        return function(d){
          // everything else should work fine
          // this should return a star obj
          var cluster = starCluster[d.cluster];
          var x = d.x - cluster.x,
            y = d.y - cluster.y,
            l = Math.sqrt(x*x + y*y),
            a = 0.5,
            r = d.radius + cluster.radius;
          if(l != r){
            l = (l - r) / l * alpha;  
            d.x -= x *= l;
            d.y -= y *= l;
          }

        };
      }

      function collide(alpha){
      // stars is not included as part of the collision detection

      var quadtree = d3.geom.quadtree(planet);
        return function(d) {
        //  console.log("d.x: " + d.x);
        //  console.log("d.y: " + d.y);
          var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
              nx1 = d.x - r,
              nx2 = d.x + r,
              ny1 = d.y - r,
              ny2 = d.y + r;

          quadtree.visit(function(quad, x1, y1, x2, y2) {
            if (quad.point && (quad.point !== d)) {
              var x = d.x - quad.point.x,
                  y = d.y - quad.point.y,
                  l = Math.sqrt(x * x + y * y),
                  r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
              if (l < r) {
                l = (l - r) / l * alpha;
                d.x -= x *= l;
                d.y -= y *= l;
                quad.point.x += x;
                quad.point.y += y;
              }
            }
            return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
          });
        };
      }

    });

    /*Define type */
    function type(d){
      d.radius = +d.radius;
      // if distance is defined, else it should be infinity
      d.distance = d.distance ? +d.distance : Infinity;
      return d;
    }

</script>
